想法：可把每個字串都想像成是一節點，而字串間如果只有一個字母有差異的話就會有邊相連
那麼就可以用 BFS 找到最短路徑

// assume there is n strings in wordList , and each string length = m
Time Complexity : O(mn^2) for O(n) nodes need O(nm) time to check if it exist in wordList and validity
Space Complexity : O(n) for the queue

class Solution {
public:
    bool valid( string &s1 , string& s2 ) {
        int count = 0 ;
        for(int i = 0 ; i < s1.length() ; i++) 
            if ( s1[i] != s2[i] )
                count++ ;
        return count <= 1 ;
    }
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        int target = -1 ;
        for(int i = 0 ; i < wordList.size() ; i++) {
            if ( endWord == wordList[i] ) {
                target = i ;
                break ;
            }
        }

        queue<pair<int , int>> candidate ;
        wordList.push_back(beginWord) ;
       vector<int> finished(wordList.size() - 1) ;
        candidate.push( { wordList.size() - 1 , 1} ) ;
        
        while ( !candidate.empty() ) {
            string now = wordList[candidate.front().first] ;
            int distance = candidate.front().second ;
            candidate.pop() ;
            for( int i = 0 ; i < wordList.size() - 1 ; i++ ) {
                if ( finished[i] == 1 )
                    continue ;
                
                if ( valid(wordList[i] , now) ) {
                    if ( i == target )
                        return distance + 1 ;
                    else {
                        candidate.push( {i , distance + 1} ) ;
                        finished[i] = 1 ;
                    }
                }
            }
        }
        return 0 ;
    }
};

// another implementation

class Solution {
public:
    bool valid(string &s1, string &s2) {
        int len = s1.length() ;
        int count = 0 ;
        for(int i = 0 ; i < len ; i++) {
            if ( s1[i] != s2[i] )
                count++ ;
        }
        return count == 1 ;
    }
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        queue<int> candidate ;
        
        int target = -1 ;
        vector<int> visited( wordList.size() ) ;
        for( int i = 0 ; i < wordList.size() ; i++) {
            if ( valid(beginWord , wordList[i]) ) {
                candidate.push(i) ;
                visited[i] = 1 ;
            }
            if ( endWord == wordList[i] )
                target = i ;
        }

        if (target == -1)
            return 0 ;

        int step = 2 ;
        while ( !candidate.empty() ) {
            int size = candidate.size() ;
            while ( size-- ) {
                int index = candidate.front() ;
                candidate.pop() ;
                if (index == target)
                    return step ;
                for(int i = 0 ; i < wordList.size() ; i++) {
                    if ( valid(wordList[index] , wordList[i]) && visited[i] != 1) {
                        candidate.push(i) ;
                        visited[i] = 1 ;
                    }
                }
            }
            step++ ;
        }

        return 0 ;
    }
};
